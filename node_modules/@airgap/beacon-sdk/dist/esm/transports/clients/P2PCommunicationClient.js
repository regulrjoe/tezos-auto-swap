var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as sodium from 'libsodium-wrappers';
import BigNumber from 'bignumber.js';
import { getHexHash, toHex, recipientString, openCryptobox, encryptCryptoboxPayload, decryptCryptoboxPayload } from '../../utils/crypto';
import { MatrixClient } from '../../matrix-client/MatrixClient';
import { MatrixClientEventType } from '../../matrix-client/models/MatrixClientEvent';
import { MatrixMessageType } from '../../matrix-client/models/MatrixMessage';
import { StorageKey } from '../..';
import { BEACON_VERSION } from '../../constants';
import { generateGUID } from '../../utils/generate-uuid';
import { getSenderId } from '../../utils/get-sender-id';
import { Logger } from '../../utils/Logger';
import { CommunicationClient } from './CommunicationClient';
const logger = new Logger('P2PCommunicationClient');
const KNOWN_RELAY_SERVERS = [
    'matrix.papers.tech'
    // 'matrix.tez.ie',
    // 'matrix-dev.papers.tech',
    // "matrix.stove-labs.com",
    // "yadayada.cryptonomic-infra.tech"
];
const clientNotReadyError = () => {
    throw new Error('Client not ready. Make sure to call "start" before you try to use it.');
};
/**
 * @internalapi
 *
 *
 */
export class P2PCommunicationClient extends CommunicationClient {
    constructor(name, keyPair, replicationCount, storage, matrixNodes, iconUrl, appUrl) {
        super(keyPair);
        this.name = name;
        this.replicationCount = replicationCount;
        this.storage = storage;
        this.iconUrl = iconUrl;
        this.appUrl = appUrl;
        this.activeListeners = new Map();
        this.ignoredRooms = [];
        logger.log('constructor', 'P2PCommunicationClient created');
        this.KNOWN_RELAY_SERVERS = matrixNodes.length > 0 ? matrixNodes : KNOWN_RELAY_SERVERS;
    }
    getPairingRequestInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const info = {
                id: yield generateGUID(),
                type: 'p2p-pairing-request',
                name: this.name,
                version: BEACON_VERSION,
                publicKey: yield this.getPublicKey(),
                relayServer: yield this.getRelayServer()
            };
            if (this.iconUrl) {
                info.icon = this.iconUrl;
            }
            if (this.appUrl) {
                info.appUrl = this.appUrl;
            }
            return info;
        });
    }
    getPairingResponseInfo(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const info = {
                id: request.id,
                type: 'p2p-pairing-response',
                name: this.name,
                version: BEACON_VERSION,
                publicKey: yield this.getPublicKey(),
                relayServer: yield this.getRelayServer()
            };
            if (this.iconUrl) {
                info.icon = this.iconUrl;
            }
            if (this.appUrl) {
                info.appUrl = this.appUrl;
            }
            return info;
        });
    }
    getRelayServer(publicKeyHash, nonce = '') {
        return __awaiter(this, void 0, void 0, function* () {
            const hash = publicKeyHash || (yield getHexHash(this.keyPair.publicKey));
            return this.KNOWN_RELAY_SERVERS.reduce((prevPromise, curr) => __awaiter(this, void 0, void 0, function* () {
                const prev = yield prevPromise;
                const prevRelayServerHash = yield getHexHash(prev + nonce);
                const currRelayServerHash = yield getHexHash(curr + nonce);
                const prevBigInt = yield this.getAbsoluteBigIntDifference(hash, prevRelayServerHash);
                const currBigInt = yield this.getAbsoluteBigIntDifference(hash, currRelayServerHash);
                return prevBigInt.isLessThan(currBigInt) ? prev : curr;
            }), Promise.resolve(this.KNOWN_RELAY_SERVERS[0]));
        });
    }
    tryJoinRooms(roomId, retry = 1) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client) {
                throw clientNotReadyError();
            }
            try {
                yield this.client.joinRooms(roomId);
            }
            catch (error) {
                if (retry <= 10 && error.errcode === 'M_FORBIDDEN') {
                    // If we join the room too fast after receiving the invite, the server can accidentally reject our join. This seems to be a problem only when using a federated multi-node setup. Usually waiting for a couple milliseconds solves the issue, but to handle lag, we will keep retrying for 2 seconds.
                    logger.log(`Retrying to join...`, error);
                    setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                        yield this.tryJoinRooms(roomId, retry + 1);
                    }), 200);
                }
                else {
                    logger.log(`Failed to join after ${retry} tries.`, error);
                }
            }
        });
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            logger.log('start', 'starting client');
            yield sodium.ready;
            const loginRawDigest = sodium.crypto_generichash(32, sodium.from_string(`login:${Math.floor(Date.now() / 1000 / (5 * 60))}`));
            const rawSignature = sodium.crypto_sign_detached(loginRawDigest, this.keyPair.privateKey);
            logger.log('start', `connecting to server`);
            const relayServer = yield this.getRelayServer(yield this.getPublicKeyHash(), '0');
            this.client = MatrixClient.create({
                baseUrl: `https://${relayServer}`,
                storage: this.storage
            });
            this.initialListener = (event) => __awaiter(this, void 0, void 0, function* () {
                if (this.initialEvent && this.initialEvent.timestamp && event && event.timestamp) {
                    if (this.initialEvent.timestamp < event.timestamp) {
                        this.initialEvent = event;
                    }
                }
                else {
                    this.initialEvent = event;
                }
            });
            this.client.subscribe(MatrixClientEventType.MESSAGE, this.initialListener);
            this.client.subscribe(MatrixClientEventType.INVITE, (event) => __awaiter(this, void 0, void 0, function* () {
                yield this.tryJoinRooms(event.content.roomId);
            }));
            logger.log('start', 'login', yield this.getPublicKeyHash(), 'on', relayServer);
            yield this.client
                .start({
                id: yield this.getPublicKeyHash(),
                password: `ed:${toHex(rawSignature)}:${yield this.getPublicKey()}`,
                deviceId: toHex(this.keyPair.publicKey)
            })
                .catch((error) => logger.log(error));
            const invitedRooms = yield this.client.invitedRooms;
            yield this.client.joinRooms(...invitedRooms).catch((error) => logger.log(error));
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.client) {
                this.client.stop().catch((error) => logger.error(error));
            }
        });
    }
    listenForEncryptedMessage(senderPublicKey, messageCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client) {
                throw clientNotReadyError();
            }
            if (this.activeListeners.has(senderPublicKey)) {
                return;
            }
            const { sharedRx } = yield this.createCryptoBoxServer(senderPublicKey, this.keyPair.privateKey);
            const callbackFunction = (event) => __awaiter(this, void 0, void 0, function* () {
                if (this.isTextMessage(event.content) && (yield this.isSender(event, senderPublicKey))) {
                    let payload;
                    try {
                        payload = Buffer.from(event.content.message.content, 'hex');
                        // content can be non-hex if it's a connection open request
                    }
                    catch (_a) {
                        /* */
                    }
                    if (payload &&
                        payload.length >= sodium.crypto_secretbox_NONCEBYTES + sodium.crypto_secretbox_MACBYTES) {
                        try {
                            const decryptedMessage = yield decryptCryptoboxPayload(payload, sharedRx);
                            // logger.log(
                            //   'listenForEncryptedMessage',
                            //   'encrypted message received',
                            //   decryptedMessage,
                            //   await new Serializer().deserialize(decryptedMessage)
                            // )
                            // console.log('calculated sender ID', await getSenderId(senderPublicKey))
                            // TODO: Add check for correct decryption key / sender ID
                            messageCallback(decryptedMessage);
                        }
                        catch (decryptionError) {
                            /* NO-OP. We try to decode every message, but some might not be addressed to us. */
                        }
                    }
                }
            });
            this.activeListeners.set(senderPublicKey, callbackFunction);
            this.client.subscribe(MatrixClientEventType.MESSAGE, callbackFunction);
            const lastEvent = this.initialEvent;
            if (lastEvent &&
                lastEvent.timestamp &&
                new Date().getTime() - lastEvent.timestamp < 5 * 60 * 1000) {
                logger.log('listenForEncryptedMessage', 'Handling previous event');
                yield callbackFunction(lastEvent);
            }
            else {
                logger.log('listenForEncryptedMessage', 'No previous event found');
            }
            if (this.initialListener) {
                this.client.unsubscribe(MatrixClientEventType.MESSAGE, this.initialListener);
            }
            this.initialListener = undefined;
            this.initialEvent = undefined;
        });
    }
    unsubscribeFromEncryptedMessage(senderPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client) {
                throw clientNotReadyError();
            }
            const listener = this.activeListeners.get(senderPublicKey);
            if (!listener) {
                return;
            }
            this.client.unsubscribe(MatrixClientEventType.MESSAGE, listener);
            this.activeListeners.delete(senderPublicKey);
        });
    }
    unsubscribeFromEncryptedMessages() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client) {
                throw clientNotReadyError();
            }
            this.client.unsubscribe(MatrixClientEventType.MESSAGE);
            this.activeListeners.clear();
        });
    }
    sendMessage(message, peer) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client) {
                throw clientNotReadyError();
            }
            const { sharedTx } = yield this.createCryptoBoxClient(peer.publicKey, this.keyPair.privateKey);
            const recipientHash = yield getHexHash(Buffer.from(peer.publicKey, 'hex'));
            const recipient = recipientString(recipientHash, peer.relayServer);
            const roomId = yield this.getRelevantRoom(recipient);
            const encryptedMessage = yield encryptCryptoboxPayload(message, sharedTx);
            // logger.log(
            //   'sendMessage',
            //   'sending encrypted message',
            //   peer.publicKey,
            //   roomId,
            //   message,
            //   await new Serializer().deserialize(message)
            // )
            this.client.sendTextMessage(roomId, encryptedMessage).catch((error) => __awaiter(this, void 0, void 0, function* () {
                if (error.errcode === 'M_FORBIDDEN') {
                    // Room doesn't exist
                    logger.log(`sendMessage`, `M_FORBIDDEN`, error);
                    yield this.deleteRoomIdFromRooms(roomId);
                    const newRoomId = yield this.getRelevantRoom(recipient);
                    if (!this.client) {
                        throw clientNotReadyError();
                    }
                    this.client.sendTextMessage(newRoomId, encryptedMessage).catch((error2) => __awaiter(this, void 0, void 0, function* () {
                        logger.log(`sendMessage`, `inner error`, error2);
                    }));
                }
                else {
                    logger.log(`sendMessage`, `not forbidden`, error);
                }
            }));
        });
    }
    deleteRoomIdFromRooms(roomId) {
        return __awaiter(this, void 0, void 0, function* () {
            const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);
            const newRoomIds = Object.entries(roomIds)
                .filter((entry) => entry[1] !== roomId)
                .reduce((pv, cv) => (Object.assign(Object.assign({}, pv), { [cv[0]]: cv[1] })), {});
            yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, newRoomIds);
            // TODO: We also need to delete the room from the sync state
            // If we need to delete a room, we can assume the local state is not up to date anymore, so we can reset the state
            this.ignoredRooms.push(roomId);
        });
    }
    listenForChannelOpening(messageCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client) {
                throw clientNotReadyError();
            }
            this.client.subscribe(MatrixClientEventType.MESSAGE, (event) => __awaiter(this, void 0, void 0, function* () {
                if (this.isTextMessage(event.content) && (yield this.isChannelOpenMessage(event.content))) {
                    logger.log(`listenForChannelOpening`, `channel opening`, JSON.stringify(event));
                    const splits = event.content.message.content.split(':');
                    const payload = Buffer.from(splits[splits.length - 1], 'hex');
                    if (payload.length >=
                        sodium.crypto_secretbox_NONCEBYTES + sodium.crypto_secretbox_MACBYTES) {
                        try {
                            const pairingResponse = JSON.parse(yield openCryptobox(payload, this.keyPair.publicKey, this.keyPair.privateKey));
                            messageCallback(Object.assign(Object.assign({}, pairingResponse), { senderId: yield getSenderId(pairingResponse.publicKey) }));
                        }
                        catch (decryptionError) {
                            /* NO-OP. We try to decode every message, but some might not be addressed to us. */
                        }
                    }
                }
            }));
        });
    }
    waitForJoin(roomId, retry = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client) {
                throw clientNotReadyError();
            }
            // Rooms are updated as new events come in. `client.getRoomById` only accesses memory, it does not do any network requests.
            // TODO: Improve to listen to "JOIN" event
            const room = yield this.client.getRoomById(roomId);
            logger.log(`waitForJoin`, `Currently ${room.members.length} members, we need at least 2`);
            if (room.members.length >= 2 || room.members.length === 0) {
                // 0 means it's an unknown room, we don't need to wait
                return;
            }
            else {
                if (retry <= 200) {
                    // On mobile, due to app switching, we potentially have to wait for a long time
                    logger.log(`Waiting for join... Try: ${retry}`);
                    return new Promise((resolve) => {
                        setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                            resolve(this.waitForJoin(roomId, retry + 1));
                        }), 100 * (retry > 50 ? 10 : 1)); // After the initial 5 seconds, retry only once per second
                    });
                }
                else {
                    throw new Error(`No one joined after ${retry} tries.`);
                }
            }
        });
    }
    sendPairingResponse(pairingRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client) {
                throw clientNotReadyError();
            }
            logger.log(`sendPairingResponse`);
            const recipientHash = yield getHexHash(Buffer.from(pairingRequest.publicKey, 'hex'));
            const recipient = recipientString(recipientHash, pairingRequest.relayServer);
            const roomId = yield this.getRelevantRoom(recipient);
            // Before we send the message, we have to wait for the join to be accepted.
            yield this.waitForJoin(roomId);
            // TODO: remove v1 backwards-compatibility
            const message = typeof pairingRequest.version === 'undefined'
                ? yield this.getPublicKey() // v1
                : JSON.stringify(yield this.getPairingResponseInfo(pairingRequest)); // v2
            const encryptedMessage = yield this.encryptMessageAsymmetric(pairingRequest.publicKey, message);
            const msg = ['@channel-open', recipient, encryptedMessage].join(':');
            this.client.sendTextMessage(roomId, msg).catch((error) => __awaiter(this, void 0, void 0, function* () {
                if (error.errcode === 'M_FORBIDDEN') {
                    // Room doesn't exist
                    logger.log(`sendMessage`, `M_FORBIDDEN`, error);
                    yield this.deleteRoomIdFromRooms(roomId);
                    const newRoomId = yield this.getRelevantRoom(recipient);
                    if (!this.client) {
                        throw clientNotReadyError();
                    }
                    this.client.sendTextMessage(newRoomId, msg).catch((error2) => __awaiter(this, void 0, void 0, function* () {
                        logger.log(`sendMessage`, `inner error`, error2);
                    }));
                }
                else {
                    logger.log(`sendMessage`, `not forbidden`, error);
                }
            }));
        });
    }
    isTextMessage(content) {
        return content.message.type === MatrixMessageType.TEXT;
    }
    isChannelOpenMessage(content) {
        return __awaiter(this, void 0, void 0, function* () {
            return content.message.content.startsWith(`@channel-open:@${yield getHexHash(Buffer.from(yield this.getPublicKey(), 'hex'))}`);
        });
    }
    isSender(event, senderPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return event.content.message.sender.startsWith(`@${yield getHexHash(Buffer.from(senderPublicKey, 'hex'))}`);
        });
    }
    getAbsoluteBigIntDifference(firstHash, secondHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const difference = new BigNumber(`0x${firstHash}`).minus(`0x${secondHash}`);
            return difference.absoluteValue();
        });
    }
    getRelevantRoom(recipient) {
        return __awaiter(this, void 0, void 0, function* () {
            const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);
            let roomId = roomIds[recipient];
            if (!roomId) {
                logger.log(`getRelevantRoom`, `No room found for peer ${recipient}, checking joined ones.`);
                const room = yield this.getRelevantJoinedRoom(recipient);
                roomId = room.id;
                roomIds[recipient] = room.id;
                yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, roomIds);
            }
            logger.log(`getRelevantRoom`, `Using room ${roomId}`);
            return roomId;
        });
    }
    getRelevantJoinedRoom(recipient) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client) {
                throw clientNotReadyError();
            }
            const joinedRooms = yield this.client.joinedRooms;
            logger.log('checking joined rooms', joinedRooms, recipient);
            const relevantRooms = joinedRooms
                .filter((roomElement) => !this.ignoredRooms.some((id) => roomElement.id === id))
                .filter((roomElement) => roomElement.members.some((member) => member === recipient));
            let room;
            // We always create a new room if one has been ignored. This is because if we ignore one, we know the server state changed.
            // So we cannot trust the current sync state. This can be removed once we have a method to properly clear and refresh the sync state.
            if (relevantRooms.length === 0 || this.ignoredRooms.length > 0) {
                logger.log(`getRelevantJoinedRoom`, `no relevant rooms found, creating new one`);
                const roomId = yield this.client.createTrustedPrivateRoom(recipient);
                room = yield this.client.getRoomById(roomId);
                logger.log(`getRelevantJoinedRoom`, `new room created and peer invited: ${room.id}`);
            }
            else {
                room = relevantRooms[0];
                logger.log(`getRelevantJoinedRoom`, `channel already open, reusing room ${room.id}`);
            }
            return room;
        });
    }
}
//# sourceMappingURL=P2PCommunicationClient.js.map